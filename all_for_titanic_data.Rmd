---
title: "all_datasets_can_be_applied"
author: "JM and HN"
date: "2023-07-18"
output: html_document
---


```{r setup}
# load packages:
require(FFTrees)
library(dplyr)
```

```{r define_costs_and_pc_missing}
# Variables needed: 
# costs could e.g. be:
cost_hi <- 1
cost_IDK_hi <- 0
cost_IDK_mi <- cost_IDK_hi
cost_mi <- -1
cost_fa <- cost_mi
cost_IDK_fa <- cost_IDK_hi
cost_IDK_cr <- cost_IDK_hi
cost_cr <- cost_hi


# define percentage that is missing in every variable of the data: 
pc <- 1 # for example
```


```{r baseline}
# build example tree with heartdisease: ----
titanic.fft <- FFTrees(formula = survived ~ .,
                     data = titanic,
                     main = "titanic")

# plot results:
plot(titanic.fft)

# define variables for further use:
# define summary statistic:
x_summary <- summary(titanic.fft)

# number of cases:
n <- x_summary$stats$train$n[1]

# number of hits:
HIT <- x_summary$stats$train$hi[1]

# number of false alarms:
FA <- x_summary$stats$train$fa[1]

# number of misses:
MI <- x_summary$stats$train$mi[1]

# number of correct rejections:
CR <- x_summary$stats$train$cr[1]

# define number of nodes that are in the tree:
nodes <- x_summary$definitions$nodes[1]


# FOR COMPARISON, old performance: ----

# Build table for overview: 
# collect values in vector:
values_o <- c(HIT, MI, FA, CR)

# Define the column and row names:
col_names_o <- c("TRUE (reality)", "FALSE (reality)")
row_names_o <- c("TRUE (decision)", "FALSE (decision)")

# Create a matrix with the values:
matrix_values_o <- matrix(values_o, nrow = length(row_names_o), ncol = length(col_names_o))

# Create a data frame:
original_table <-  data.frame(matrix_values_o, row.names = row_names_o)

# Rename the columns:
colnames(original_table) <- col_names_o

# Print the original table:
print(original_table)

# old performance in pc: ----
# Divide each cell by n:
pc_original_table <- original_table %>%
  mutate_all(~ . / n)

# new column names:
col_names_o <- c("TRUE (reality) %", "FALSE (reality) %")

# Rename the columns:
colnames(pc_original_table) <- col_names_o

# Print the new data frame:
print(pc_original_table)


# calculating costs: ----

# probabilities taken from the table above:
original_costs <- pc_original_table$`TRUE (reality) %`[1] * cost_hi +
                  pc_original_table$`TRUE (reality) %`[2] * cost_mi +
                  pc_original_table$`FALSE (reality) %`[1] * cost_fa +
                  pc_original_table$`FALSE (reality) %`[2] * cost_cr 
      



```

```{r 1_IDK_last_node}
# In this variant all data with missings is passed on to the next node and processed there. ----
# Only missings in all variables (which are used for the FFTree) are then put in category IDK.

# number of missings in all categories:
p <- pc^nodes
p

# build table with new performance data:
# Define the values for each cell:
hit <- HIT - (HIT * p)
IDK_hit <- HIT * p
IDK_mi <- MI * p
mi <- MI - (MI * p)
fa <- FA - (FA * p)
IDK_fa <- FA * p
IDK_cr <- CR * p
cr <- CR - (CR * p)

# collect in vector:
values <- c(hit, IDK_hit, IDK_mi, mi, fa, IDK_fa, IDK_cr, cr)

# Define the column and row names:
col_names <- c("TRUE (reality)", "FALSE (reality)")
row_names <- c("TRUE (decision)", "IDK_TRUE (decision)", "IDK_FALSE (decision)", "FALSE (decision)")

# Create a matrix with the values:
matrix_values <- matrix(values, nrow = length(row_names), ncol = length(col_names))

# Create a data frame:
table <- data.frame(matrix_values, row.names = row_names)

# Rename the columns:
colnames(table) <- col_names

# Print the table:
print(table)

# check whether sum is correct:
sum(as.matrix(table))


# Calculate the percentages:----
# Divide each cell by n:
pc_table <- table %>%
  mutate_all(~ . / n)

# new column names:
col_names <- c("TRUE (reality) %", "FALSE (reality) %")

# Rename the columns:
colnames(pc_table) <- col_names

# Print the new data frame:
print(pc_table)

# check whether sum is correct:
sum(as.matrix(pc_table))

# calculating costs: ----

# probabilities taken from the table above:
IDK_1_costs <- pc_table$`TRUE (reality) %`[1] * cost_hi +
               pc_table$`TRUE (reality) %`[2] * cost_IDK_hi +
               pc_table$`TRUE (reality) %`[3] * cost_IDK_mi +
               pc_table$`TRUE (reality) %`[4] * cost_mi +
               pc_table$`FALSE (reality) %`[1] * cost_fa +
               pc_table$`FALSE (reality) %`[2] * cost_IDK_fa +
               pc_table$`FALSE (reality) %`[3] * cost_IDK_cr +
               pc_table$`FALSE (reality) %`[4] * cost_cr 
```

```{r IDK_every_node}
# In this case p% in each variable will be excluded directly since they are missings and cannot be classified:----
# number of missings in all categories:
p_all <-  pc + (1-pc)*pc + (1-pc)*(1-pc)*pc
p_all

# build table with new performance data:
# Define the values for each cell:
hit <- HIT - (HIT * p_all)
IDK_hit <- HIT * p_all
IDK_mi <- MI * p_all
mi <- MI - (MI * p_all)
fa <- FA - (FA * p_all)
IDK_fa <- FA * p_all
IDK_cr <- CR * p_all
cr <- CR - (CR * p_all)

# collect in vector:
values <- c(hit, IDK_hit, IDK_mi, mi, fa, IDK_fa, IDK_cr, cr)

# Define the column and row names:
col_names <- c("TRUE (reality)", "FALSE (reality)")
row_names <- c("TRUE (decision)", "IDK_TRUE (decision)", "IDK_FALSE (decision)", "FALSE (decision)")

# Create a matrix with the values:
matrix_values <- matrix(values, nrow = length(row_names), ncol = length(col_names))

# Create a data frame:
table_all <- data.frame(matrix_values, row.names = row_names)

# Rename the columns:
colnames(table_all) <- col_names

# Print the table_all:
print(table_all)

# check whether sum is correct:
sum(as.matrix(table_all))


# Calculate the percentages:----
# Divide each cell by n:
pc_table_all <- table_all %>%
  mutate_all(~ . / n)

# new column names:
col_names <- c("TRUE (reality) %", "FALSE (reality) %")

# Rename the columns:
colnames(pc_table_all) <- col_names

# Print the new data frame:
print(pc_table_all)

# check whether sum is correct:
sum(as.matrix(pc_table_all))

# calculating costs: ----

# probabilities taken from the table_all above:
IDK_all_costs <- pc_table_all$`TRUE (reality) %`[1] * cost_hi +
  pc_table_all$`TRUE (reality) %`[2] * cost_IDK_hi +
  pc_table_all$`TRUE (reality) %`[3] * cost_IDK_mi +
  pc_table_all$`TRUE (reality) %`[4] * cost_mi +
  pc_table_all$`FALSE (reality) %`[1] * cost_fa +
  pc_table_all$`FALSE (reality) %`[2] * cost_IDK_fa +
  pc_table_all$`FALSE (reality) %`[3] * cost_IDK_cr +
  pc_table_all$`FALSE (reality) %`[4] * cost_cr 
```


# Define some functions: ----
```{r  Define_functions_replace_values}
# Define Loop functions (for multiple simulations) ----
replace_values <- function(data, cols, amount, replacement = NA, levels_amount = NULL) {


  # Verify inputs ----
  testthat::expect_true(is.data.frame(data), info = "Data should be a dataframe.") # check that data is a data frame.
  testthat::expect_true(all(cols %in% names(data)), info = "All column names should be present in the data.") # check that columns is/are all variables in the data frame.
  testthat::expect_true(length(cols) == length(amount), info = "Number of columns and percentages have to match.") # check if columns and percentages are of the same length.
  testthat::expect_true(all(is.numeric(amount) & (amount >= 0) ), info = "All amounts should be numeric values.") # check that percentages are all numbers between 0 and 1, or higher (than treat as number of to be replaced values.
  testthat::expect_true(is.character(replacement) | is.numeric(replacement) | is.logical(replacement) | is.na(replacement), info = "Replacement value should be of a valid data type (character, nummeric, logical or NA).") # check that replacement is a valid data type.
  testthat::expect_true(is.null(levels_amount) | is.list(levels_amount), info = "levels_amount should be a list") # check that levels_amount is a list if it's not NULL.
  if (!is.null(levels_amount)) {
    testthat::expect_true(all(names(levels_amount) %in% cols), info = "All names in levels_amount have to correspond to a column in the data.") # check if all elements in levels_amount correspond to a column in the data frame.
    for (col in names(levels_amount)) {
      if (is.factor(data[[col]])) {
        testthat::expect_true(all(names(levels_amount[[col]]) %in% levels(data[[col]])), info = "All levels in levels_amount have to be present in the corresponding column of the data.") # check if all sub-elements in each element are valid levels in the corresponding factor variable.

         }

      else if (is.character(data[[col]])) {
        testthat::expect_true(all(names(levels_amount[[col]]) %in% unique(data[[col]])), info = "All levels in levels_amount have to be present in the corresponding column of the data.")

         }

     }

  }
  # main: ----

  # loop function over all columns that are inserted in form of a vector and corresponding percentages:
  for (i in seq_along(cols)) {

    col <- cols[i]
    perc <- amount[i]


    # Check if the specific column is a factor and has levels_amount defined:
    if (is.factor(data[[col]]) || is.character(data[[col]]) && !is.null(levels_amount) && col %in% names(levels_amount)) {

      # if all these conditions apply for the column, code is executed:
      # get list of different replacement percentages of levels in column:
      lev_amount <- levels_amount[[col]]

      # loop over levels in current column:
      for (cat in names(lev_amount)) {

        # get replacement percentage for current category:
        replace_perc <- lev_amount[[cat]]

        # get rows in column for current category:
        rows <- which(data[[col]] == cat)

        # Calculate how many values should be replaced in category:
        num_replace <-  ifelse(replace_perc <= 1, round(replace_perc * length(rows), 0), replace_perc)

        # Use sample to replace specified percentage of category with replacement input:
        replace_rows <- sample(rows, size = num_replace[1],  replace = FALSE)
        data[replace_rows, col] <- replacement

      }

    } else {

      # Calculate how many values should be replaced:
      num_values <- nrow(data)
      num_replace <-  ifelse(amount <= 1, round(amount * num_values, 0), amount)

      # Use sample to replace specified percentage with replacement input:
      replace_rows <- sample(1:num_values,size = num_replace[1],  replace = FALSE)
      data[replace_rows, col] <- replacement

    }

  }

  # Output: ----

  return(data) # as data frame.

} # replace_values().

```

```{r define-loop-NA-function}

loop_NA <- function(data, criterion, pc, x, fft_df, x_stats_1){


# Prepare for loop:
  # Parameters:
  n_per_NA <- 10
  n_sims <- n_per_NA

# initialize data structure to collect results:
results <- data.frame(matrix(NA, nrow = 1 + n_sims, ncol = 26))

# results:
n_col <- ncol(x_stats_1)
results[1, 1:n_col] <- x_stats_1

  
# Prepare vectors as input for replace_values function:  
   # get all names of variables but exclude criterion: 
   col_names <- names(data)
   col_names <- col_names[col_names != criterion ]
  
   # build vector with NA percentage: 
   num_cols <- length(col_names)
   pc_per_row <- pc

   # create vector with that pc for number of rows:
   pc_vec <- rep(pc_per_row, times = num_cols)

   # set seed for reproducability:
   set.seed(13)
  
# Loop 1: ---- 
for (i in 1:n_sims){

# Add NAs to data:
data_NA <- replace_values(data = data, 
                          cols = col_names, 
                          amount = pc_vec, 
                          replacement = NA, 
                          levels_amount = NULL)

  
# Apply tree definition to (OLD/NBW) data:
y <- FFTrees(object = x,
             tree.definitions = fft_df,
             data = data_NA, 
             quiet = TRUE, 
             do.comp = FALSE)

# Collect results:

# a) tree performance: 
y_summary <- summary(y)
y_stats <- y_summary$stats$train

# b) level stats:
y_level_stats <- y$trees$level_stats$train
NA_stats <- y_level_stats[nrow(y_level_stats) , c(25 :30)]

# Combine:
all_data_df <- cbind(y_stats, NA_stats)
# dim(all_data_df)


# Collect results:
results[(1 + i), ] <- all_data_df

} # for loop. 

  
# After loop:

# Add column names to data frame:
names(results) <- names(all_data_df)

       
# Output: ----
return(results) # as data frame.

} # loop_NA().
```

```{r define-loop-pc-function}

# as input a vector with different pcs for which you want data:

loop_pc <- function(data, data_name, criterion, several_pcs, x, fft_df, x_stats_1){

  # Initialize list to store results:
  results_dataframes <-  list()

  # length of vector, to know when to stop:
  n <- length(several_pcs)

  # Loop 2:
  for (j in 1:n) {

    # use function loop_NA and give name to each data frame:
    result_name <- paste0(data_name, "_", several_pcs[j]*100, "pc")
    results_dataframes[[result_name]] <- loop_NA(data, criterion, several_pcs[j], x, fft_df, x_stats_1)

  } # for loop.
  
  # Output: ----
  
  return(results_dataframes)# as list.

} # loop_pc.

```

```{r define-loop-datasets-function}

# as input a vector with different data sets for which you want data:

loop_datasets <- function(several_data, data_names, several_criterion, several_pcs){

  # Preparations:
  # length of vector, to know when to stop:
  n <- length(several_data)


  # Initialize list to store results:
  results_list_dataframes <-  list()
  
  # Initialize list to store results of Baseline-pc:
  baseline_pc <- numeric(n)

  
  # Initialize two nummeric vectors to store results of Baseline-pc:
  bl <- numeric(n)
  pred_benchmark <- numeric(n)
  
  # Loop 3:
  for (k in 1:n) {

    # build tree with original data for each dataset:
    # get name of data set:
    name <- data_names[k]

    #Build tree for normal data set:
    x <- FFTrees(formula = as.formula(paste(several_criterion[k],"~.")),
                 data = several_data[[k]],
                 main = name,
                 goal = "bacc",
                 goal.chase = "bacc",
                 goal.threshold = "bacc")

    # Performance:
    x_summary <- summary(x)
    x_stats_1 <- x_summary$stats$train[1, ]

    # get tree definitions:
    x_fft_df <- get_fft_df(x)
    fft_df <- x_fft_df[1, ]  # best training tree



    # use function loop_pc:
    results_list_dataframes[[data_names[k]]] <- loop_pc(several_data[[k]], data_names[k], several_criterion[k], several_pcs, x, fft_df, x_stats_1)

    
    
    # describe data for further table:
    dd <- describe_data(several_data[[k]], 
                    data_name = name, 
                    criterion_name = several_criterion[k], 
                    baseline_value = TRUE)

    # Baseline:
    bl[k] <- dd$Baseline_pct

    # Minimum prediction performance (i.e., majority of criterion):
    pred_benchmark[k] <- max(bl[k], 100 - bl[k])/100
    
    # store baseline_pc:
    baseline_pc[k] <- pred_benchmark[k]

    
  } # for loop.
  
  # Output: ----
  
  return(list(results = results_list_dataframes, baseline = baseline_pc)) # as list.

} # loop_datasets.
```

# Handle NA with FFTrees: ----
```{r run-simulation}
# Use function for example 25%: ----

dfs <- loop_datasets(several_data = list(titanic),
                      data_names = c("titanic"), 
                      several_criterion = c("survived"),
                      several_pcs = c(pc))


# assign names to output dfs: ----
# list of names
names_list <- c("titanic")

# list of percentages
pc_100 <- pc * 100
percent_list <- c(pc_100)

# loop over names
for (name in names_list) {
  
  # loop over percentages
  for (percent in percent_list) {
    
    # create the name of the dataframe in dfs$results
    df_name <- paste0(name, "_", percent, "pc")
    
    # create the name of the variable
    var_name <- paste0(name, "_NA_", percent)
    
    # assign the dataframe to a new variable
    assign(var_name, dfs$results[[name]][[df_name]])
  }
}
```

```{r key-results}

# Collect key results (in df): ----
key_results <- data.frame(matrix(NA, nrow = 2, ncol = 5))
names(key_results) <- c("pc_NA", "mn_hi", "mn_fa", "mn_mi", "mn_cr")

# Construct the variable name
input_var <- paste0("titanic_NA_", pc_100)

# Row 1: mean values
key_results[1, "pc_NA"] <- pc_100
key_results[1, "mn_hi"] <- mean(get(input_var)$hi[-1])
key_results[1, "mn_fa"] <- mean(get(input_var)$fa[-1])
key_results[1, "mn_mi"] <- mean(get(input_var)$mi[-1])
key_results[1, "mn_cr"] <- mean(get(input_var)$cr[-1])

# Row 2: in pc
key_results[2, "pc_NA"] <- pc_100
key_results[2, "mn_hi"] <- mean(get(input_var)$hi[-1]) / n
key_results[2, "mn_fa"] <- mean(get(input_var)$fa[-1]) / n
key_results[2, "mn_mi"] <- mean(get(input_var)$mi[-1]) / n
key_results[2, "mn_cr"] <- mean(get(input_var)$cr[-1]) / n

key_results
```


```{r calculate_costs}

# probabilities taken from the table above:
 handle_NA_costs <- key_results$mn_hi[2] * cost_hi +
                    key_results$mn_mi[2] * cost_mi +
                    key_results$mn_fa[2] * cost_fa +
                    key_results$mn_cr[2] * cost_cr 
```



# Compare different proceedings: ----
```{r Compare_costs_across_proceedings}

# Compare performances with costs: ----
# Define the column names and values
col_names <- c("original_costs", "IDK_1_costs", "IDK_all_costs", "handle_NA_costs")
values <- as.numeric(c(original_costs, IDK_1_costs, IDK_all_costs, handle_NA_costs))

# Create the data frame
df <- data.frame(t(values))
colnames(df) <- col_names

# Print the data frame
print(df)
```

```{r display_costs_in_barplot}

# Create  bar plot: ----
barplot(height = values, names = col_names, ylim = c(0, 1), xlab = "procedure", ylab = "Performance", main = "Costs of different procedures to handle missings.")
```






# build table, cost of hi, cr = 1 and fa, mi = cost_hi * x, IDK = 0: ----
```{r table-all-x-IDK-0}
# Define x: ----
x <- seq(-10, 0, length.out = 100)

# Variables needed:----
cost_IDK <- 0
cost_hi <- -1
cost_IDK_hi <- cost_IDK
cost_IDK_mi <- cost_IDK
cost_mi <- x * cost_hi
cost_fa <- cost_mi
cost_IDK_fa <- cost_IDK
cost_IDK_cr <- cost_IDK
cost_cr <- cost_hi

# Calculate all y: ----
# Calculate y1 for each x value:
original <- pc_original_table$`TRUE (reality) %`[1] * cost_hi +
      pc_original_table$`TRUE (reality) %`[2] * cost_mi +
      pc_original_table$`FALSE (reality) %`[1] * cost_fa +
      pc_original_table$`FALSE (reality) %`[2] * cost_cr

# Calculate y2 for each x value (example calculation):
IDK_1 <- pc_table$`TRUE (reality) %`[1] * cost_hi +
               pc_table$`TRUE (reality) %`[2] * cost_IDK_hi +
               pc_table$`TRUE (reality) %`[3] * cost_IDK_mi +
               pc_table$`TRUE (reality) %`[4] * cost_mi +
               pc_table$`FALSE (reality) %`[1] * cost_fa +
               pc_table$`FALSE (reality) %`[2] * cost_IDK_fa +
               pc_table$`FALSE (reality) %`[3] * cost_IDK_cr +
               pc_table$`FALSE (reality) %`[4] * cost_cr 

# Calculate y3 for each x value (example calculation):
IDK_all <- pc_table_all$`TRUE (reality) %`[1] * cost_hi +
  pc_table_all$`TRUE (reality) %`[2] * cost_IDK_hi +
  pc_table_all$`TRUE (reality) %`[3] * cost_IDK_mi +
  pc_table_all$`TRUE (reality) %`[4] * cost_mi +
  pc_table_all$`FALSE (reality) %`[1] * cost_fa +
  pc_table_all$`FALSE (reality) %`[2] * cost_IDK_fa +
  pc_table_all$`FALSE (reality) %`[3] * cost_IDK_cr +
  pc_table_all$`FALSE (reality) %`[4] * cost_cr 

# Calculate y4:
 FFT_handle <- key_results$mn_hi[2] * cost_hi +
                    key_results$mn_mi[2] * cost_mi +
                    key_results$mn_fa[2] * cost_fa +
                    key_results$mn_cr[2] * cost_cr 

# Plot the graph with multiple y variables: ----
plot(x, original, type = "l",ylim = c(-2,2), col = "red", xlab = "costs false decisions (x * correct decisions)", ylab = "Costs",
main = "Total costs depending on the relationship from costs of false to correct decisions.")
lines(x, IDK_1, col = "darkgreen")
lines(x, IDK_all, col = "green")
lines(x, FFT_handle, col = "orange")

# Add a legend to the graph
legend("bottomleft", legend = c("Original Data", "IDK_one_node", "IDK_all_nodes", "FFT_handle_NAs"), col = c("red", "darkgreen", "green", "orange"), lty = 1)

```


# calculations ----

```{r Intersection-original-1-IDk}
# Define the two functions: ----
original <-  function(x) pc_original_table$`TRUE (reality) %`[1] * cost_hi +
      pc_original_table$`TRUE (reality) %`[2] *  x * cost_hi +
      pc_original_table$`FALSE (reality) %`[1] *  x * cost_hi +
      pc_original_table$`FALSE (reality) %`[2] * cost_cr


one_IDK <- function(x)pc_table$`TRUE (reality) %`[1] * cost_hi +
               pc_table$`TRUE (reality) %`[2] * cost_IDK_hi +
               pc_table$`TRUE (reality) %`[3] * cost_IDK_mi +
               pc_table$`TRUE (reality) %`[4] *  x * cost_hi +
               pc_table$`FALSE (reality) %`[1] *  x * cost_hi +
               pc_table$`FALSE (reality) %`[2] * cost_IDK_fa +
               pc_table$`FALSE (reality) %`[3] * cost_IDK_cr +
               pc_table$`FALSE (reality) %`[4] * cost_cr 
    


# Find the intersection point: ----
intersection <- uniroot(function(x)  one_IDK(x) - original(x), interval = c(-1000, 1000))
intersection_point_IDK_1_original <- intersection$root

# Print the intersection point:
intersection_point_IDK_1_original
```

```{r Intersection-FFT-handle-1-IDk}
# Define the two functions: ----
FFT_handle <-  function(x) key_results$mn_hi[2] * cost_hi +
                    key_results$mn_mi[2] * x * cost_hi +
                    key_results$mn_fa[2] * x * cost_hi +
                    key_results$mn_cr[2] * cost_cr 


one_IDK <- function(x)pc_table$`TRUE (reality) %`[1] * cost_hi +
               pc_table$`TRUE (reality) %`[2] * cost_IDK_hi +
               pc_table$`TRUE (reality) %`[3] * cost_IDK_mi +
               pc_table$`TRUE (reality) %`[4] *  x * cost_hi +
               pc_table$`FALSE (reality) %`[1] *  x * cost_hi +
               pc_table$`FALSE (reality) %`[2] * cost_IDK_fa +
               pc_table$`FALSE (reality) %`[3] * cost_IDK_cr +
               pc_table$`FALSE (reality) %`[4] * cost_cr 
    

# Find the intersection point: ----
intersection <- uniroot(function(x)  one_IDK(x)  - FFT_handle(x), interval = c(-1000, 1000))
intersection_point_IDK_1_FFT_handle <- intersection$root

# Print the intersection point:
intersection_point_IDK_1_FFT_handle
```

```{r Intersection-original-all-IDk}
# Define the two functions: ----
original <-  function(x) pc_original_table$`TRUE (reality) %`[1] * cost_hi +
      pc_original_table$`TRUE (reality) %`[2] *  x * cost_hi +
      pc_original_table$`FALSE (reality) %`[1] *  x * cost_hi +
      pc_original_table$`FALSE (reality) %`[2] * cost_cr


all_IDK <- function(x) pc_table_all$`TRUE (reality) %`[1] * cost_hi +
  pc_table_all$`TRUE (reality) %`[2] * cost_IDK_hi +
  pc_table_all$`TRUE (reality) %`[3] * cost_IDK_mi +
  pc_table_all$`TRUE (reality) %`[4] * x * cost_hi +
  pc_table_all$`FALSE (reality) %`[1] * x * cost_hi +
  pc_table_all$`FALSE (reality) %`[2] * cost_IDK_fa +
  pc_table_all$`FALSE (reality) %`[3] * cost_IDK_cr +
  pc_table_all$`FALSE (reality) %`[4] * cost_cr 
  
  
# Find the intersection point: ----
intersection <- uniroot(function(x)  all_IDK(x) - original(x), interval = c(-1000, 1000))
intersection_point_IDK_all_original <- intersection$root

# Print the intersection point
intersection_point_IDK_all_original
```

```{r Intersection-FFT-handle-all-IDk}
# Define the two functions: ----
FFT_handle <-  function(x) key_results$mn_hi[2] * cost_hi +
                    key_results$mn_mi[2] * x * cost_hi +
                    key_results$mn_fa[2] * x * cost_hi +
                    key_results$mn_cr[2] * cost_cr 

all_IDK <- function(x) pc_table_all$`TRUE (reality) %`[1] * cost_hi +
  pc_table_all$`TRUE (reality) %`[2] * cost_IDK_hi +
  pc_table_all$`TRUE (reality) %`[3] * cost_IDK_mi +
  pc_table_all$`TRUE (reality) %`[4] * x * cost_hi +
  pc_table_all$`FALSE (reality) %`[1] * x * cost_hi +
  pc_table_all$`FALSE (reality) %`[2] * cost_IDK_fa +
  pc_table_all$`FALSE (reality) %`[3] * cost_IDK_cr +
  pc_table_all$`FALSE (reality) %`[4] * cost_cr 


# Find the intersection point: ----
intersection <- uniroot(function(x)  all_IDK(x) - FFT_handle(x), interval = c(-1000, 1000))
intersection_point_IDK_all_FFT_handle <- intersection$root

# Print the intersection point
intersection_point_IDK_all_FFT_handle
```

```{r collect-intersection-points}
# collect all intersection points: ----
all_intersection_points <- c(intersection_point_IDK_1_original, intersection_point_IDK_1_FFT_handle, intersection_point_IDK_all_original, intersection_point_IDK_all_FFT_handle )

# filter only important variable: 
costs_false_intersections_100 <- all_intersection_points
```

```{r display-intersection-points}
# display saved performance: ----
costs_false_intersections_05
costs_false_intersections_10
costs_false_intersections_20
costs_false_intersections_25 
costs_false_intersections_50
costs_false_intersections_60
costs_false_intersections_75
costs_false_intersections_100
```



```{r compare-1-IDK-FFT-handle-false-decision-is-x}

# define the costs of false decision where 1_IDK and FFT_handle fucntion meet:
costs_false_decisions <- c(costs_false_intersections_05[2],
costs_false_intersections_10[2],
costs_false_intersections_20[2],
costs_false_intersections_25[2], 
costs_false_intersections_50[2],
costs_false_intersections_60[2],
costs_false_intersections_75[2],
costs_false_intersections_100[2])

# define pc that is missing: 
pc_missings <- c(5, 10, 20, 25, 50, 60, 75, 100)

# plot both and a vertical line at 0, that is the cost of IDK decisions: 
plot(pc_missings, costs_false_decisions , type='o',lty=2,col='darkgreen',lwd=1, main = "Costs of False decisions, where when more expensive 1_IDK starts performing better than FFT_handle.")
abline(h = 0, col='red',lty = 2)





```

```{r calculate-at-which-pc-missings-costs-of-false-decision-only-has-to-be-as-good-as-no-decision-for-fft-handle-to-have-lower-costs}

# Define the function for the line connecting the points:
line_function <- function(x) {
  approx(x = pc_missings, y = costs_false_decisions, xout = x)$y
}

# Find the intersection point with the vertical line:
intersection <- uniroot(function(x) line_function(x), interval = range(pc_missings))
intersection_point <- intersection$root
intersection_point

```


```{r compare-all-IDK-FFT-handle}

# define the costs of false decision where all_IDK and FFT_handle fucntion meet:
costs_false_decisions <- c(costs_false_intersections_05[4],
costs_false_intersections_10[4],
costs_false_intersections_20[4],
costs_false_intersections_25[4], 
costs_false_intersections_50[4],
costs_false_intersections_60[4],
costs_false_intersections_75[4],
costs_false_intersections_100[4])

# define pc that is missing: 
pc_missings <- c(5, 10, 20, 25, 50, 60, 75, 100)

# plot both and a vertical line at 0, that is the cost of IDK decisions: 
plot(pc_missings, costs_false_decisions , type='o',lty=2,ylim = c(-4,2),col='darkgreen',lwd=1,  main = "Costs of False decisions, where when more expensive all_IDK starts performing better than FFT_handle.")
abline(h = 0, col='red',lty = 2)

```
