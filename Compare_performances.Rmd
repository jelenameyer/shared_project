---
title: "Compare_Performances"
author: "JM and HN"
date: "2023-07-06"
output: html_document
---
```{r setup}
# load packages:
require(FFTrees)
library(dplyr)
```

```{r define_costs_and_pc_missing}
# Variables needed: 
# costs could e.g. be:
cost_hi <- 1
cost_IDK_hi <- 0
cost_IDK_mi <- cost_IDK_hi
cost_mi <- -1
cost_fa <- cost_mi
cost_IDK_fa <- cost_IDK_hi
cost_IDK_cr <- cost_IDK_hi
cost_cr <- cost_hi


# define percentage that is missing in every variable of the data: 
pc <- 0.25 # for example
```


```{r baseline}
# build example tree with heartdisease: ----
heart.fft <- FFTrees(formula = diagnosis ~ .,
                     data = heartdisease,
                     main = "Heart Disease")

# plot results:
plot(heart.fft)

# define variables for further use:
# define summary statistic:
x_summary <- summary(heart.fft)

# number of cases:
n <- x_summary$stats$train$n[1]

# number of hits:
HIT <- x_summary$stats$train$hi[1]

# number of false alarms:
FA <- x_summary$stats$train$fa[1]

# number of misses:
MI <- x_summary$stats$train$mi[1]

# number of correct rejections:
CR <- x_summary$stats$train$cr[1]

# define number of nodes that are in the tree:
nodes <- x_summary$definitions$nodes[1]


# FOR COMPARISON, old performance: ----

# Build table for overview: 
# collect values in vector:
values_o <- c(HIT, MI, FA, CR)

# Define the column and row names:
col_names_o <- c("TRUE (reality)", "FALSE (reality)")
row_names_o <- c("TRUE (decision)", "FALSE (decision)")

# Create a matrix with the values:
matrix_values_o <- matrix(values_o, nrow = length(row_names_o), ncol = length(col_names_o))

# Create a data frame:
original_table <-  data.frame(matrix_values_o, row.names = row_names_o)

# Rename the columns:
colnames(original_table) <- col_names_o

# Print the original table:
print(original_table)

# old performance in pc: ----
# Divide each cell by n:
pc_original_table <- original_table %>%
  mutate_all(~ . / n)

# new column names:
col_names_o <- c("TRUE (reality) %", "FALSE (reality) %")

# Rename the columns:
colnames(pc_original_table) <- col_names_o

# Print the new data frame:
print(pc_original_table)


# calculating costs: ----

# probabilities taken from the table above:
original_costs <- pc_original_table$`TRUE (reality) %`[1] * cost_hi +
                  pc_original_table$`TRUE (reality) %`[2] * cost_mi +
                  pc_original_table$`FALSE (reality) %`[1] * cost_fa +
                  pc_original_table$`FALSE (reality) %`[2] * cost_cr 
      



```

```{r 1_IDK_last_node}
# In this variant all data with missings is passed on to the next node and processed there. ----
# Only missings in all variables (which are used for the FFTree) are then put in category IDK.

# number of missings in all categories:
p <- pc^nodes
p

# build table with new performance data:
# Define the values for each cell:
hit <- HIT - (HIT * p)
IDK_hit <- HIT * p
IDK_mi <- MI * p
mi <- MI - (MI * p)
fa <- FA - (FA * p)
IDK_fa <- FA * p
IDK_cr <- CR * p
cr <- CR - (CR * p)

# collect in vector:
values <- c(hit, IDK_hit, IDK_mi, mi, fa, IDK_fa, IDK_cr, cr)

# Define the column and row names:
col_names <- c("TRUE (reality)", "FALSE (reality)")
row_names <- c("TRUE (decision)", "IDK_TRUE (decision)", "IDK_FALSE (decision)", "FALSE (decision)")

# Create a matrix with the values:
matrix_values <- matrix(values, nrow = length(row_names), ncol = length(col_names))

# Create a data frame:
table <- data.frame(matrix_values, row.names = row_names)

# Rename the columns:
colnames(table) <- col_names

# Print the table:
print(table)

# check whether sum is correct:
sum(as.matrix(table))


# Calculate the percentages:----
# Divide each cell by n:
pc_table <- table %>%
  mutate_all(~ . / n)

# new column names:
col_names <- c("TRUE (reality) %", "FALSE (reality) %")

# Rename the columns:
colnames(pc_table) <- col_names

# Print the new data frame:
print(pc_table)

# check whether sum is correct:
sum(as.matrix(pc_table))

# calculating costs: ----

# probabilities taken from the table above:
IDK_1_costs <- pc_table$`TRUE (reality) %`[1] * cost_hi +
               pc_table$`TRUE (reality) %`[2] * cost_IDK_hi +
               pc_table$`TRUE (reality) %`[3] * cost_IDK_mi +
               pc_table$`TRUE (reality) %`[4] * cost_mi +
               pc_table$`FALSE (reality) %`[1] * cost_fa +
               pc_table$`FALSE (reality) %`[2] * cost_IDK_fa +
               pc_table$`FALSE (reality) %`[3] * cost_IDK_cr +
               pc_table$`FALSE (reality) %`[4] * cost_cr 
```

```{r IDK_every_node}
# In this case p% in each variable will be excluded directly since they are missings and cannot be classified:----
# number of missings in all categories:
p_all <-  pc + (1-pc)*pc + (1-pc)*(1-pc)*pc
p_all

# build table with new performance data:
# Define the values for each cell:
hit <- HIT - (HIT * p_all)
IDK_hit <- HIT * p_all
IDK_mi <- MI * p_all
mi <- MI - (MI * p_all)
fa <- FA - (FA * p_all)
IDK_fa <- FA * p_all
IDK_cr <- CR * p_all
cr <- CR - (CR * p_all)

# collect in vector:
values <- c(hit, IDK_hit, IDK_mi, mi, fa, IDK_fa, IDK_cr, cr)

# Define the column and row names:
col_names <- c("TRUE (reality)", "FALSE (reality)")
row_names <- c("TRUE (decision)", "IDK_TRUE (decision)", "IDK_FALSE (decision)", "FALSE (decision)")

# Create a matrix with the values:
matrix_values <- matrix(values, nrow = length(row_names), ncol = length(col_names))

# Create a data frame:
table_all <- data.frame(matrix_values, row.names = row_names)

# Rename the columns:
colnames(table_all) <- col_names

# Print the table_all:
print(table_all)

# check whether sum is correct:
sum(as.matrix(table_all))


# Calculate the percentages:----
# Divide each cell by n:
pc_table_all <- table_all %>%
  mutate_all(~ . / n)

# new column names:
col_names <- c("TRUE (reality) %", "FALSE (reality) %")

# Rename the columns:
colnames(pc_table_all) <- col_names

# Print the new data frame:
print(pc_table_all)

# check whether sum is correct:
sum(as.matrix(pc_table_all))

# calculating costs: ----

# probabilities taken from the table_all above:
IDK_all_costs <- pc_table_all$`TRUE (reality) %`[1] * cost_hi +
  pc_table_all$`TRUE (reality) %`[2] * cost_IDK_hi +
  pc_table_all$`TRUE (reality) %`[3] * cost_IDK_mi +
  pc_table_all$`TRUE (reality) %`[4] * cost_mi +
  pc_table_all$`FALSE (reality) %`[1] * cost_fa +
  pc_table_all$`FALSE (reality) %`[2] * cost_IDK_fa +
  pc_table_all$`FALSE (reality) %`[3] * cost_IDK_cr +
  pc_table_all$`FALSE (reality) %`[4] * cost_cr 
```


# Define some functions: ----
```{r  Define_functions_replace_values}
# Define Loop functions (for multiple simulations) ----
replace_values <- function(data, cols, amount, replacement = NA, levels_amount = NULL) {


  # Verify inputs ----
  testthat::expect_true(is.data.frame(data), info = "Data should be a dataframe.") # check that data is a data frame.
  testthat::expect_true(all(cols %in% names(data)), info = "All column names should be present in the data.") # check that columns is/are all variables in the data frame.
  testthat::expect_true(length(cols) == length(amount), info = "Number of columns and percentages have to match.") # check if columns and percentages are of the same length.
  testthat::expect_true(all(is.numeric(amount) & (amount >= 0) ), info = "All amounts should be numeric values.") # check that percentages are all numbers between 0 and 1, or higher (than treat as number of to be replaced values.
  testthat::expect_true(is.character(replacement) | is.numeric(replacement) | is.logical(replacement) | is.na(replacement), info = "Replacement value should be of a valid data type (character, nummeric, logical or NA).") # check that replacement is a valid data type.
  testthat::expect_true(is.null(levels_amount) | is.list(levels_amount), info = "levels_amount should be a list") # check that levels_amount is a list if it's not NULL.
  if (!is.null(levels_amount)) {
    testthat::expect_true(all(names(levels_amount) %in% cols), info = "All names in levels_amount have to correspond to a column in the data.") # check if all elements in levels_amount correspond to a column in the data frame.
    for (col in names(levels_amount)) {
      if (is.factor(data[[col]])) {
        testthat::expect_true(all(names(levels_amount[[col]]) %in% levels(data[[col]])), info = "All levels in levels_amount have to be present in the corresponding column of the data.") # check if all sub-elements in each element are valid levels in the corresponding factor variable.

         }

      else if (is.character(data[[col]])) {
        testthat::expect_true(all(names(levels_amount[[col]]) %in% unique(data[[col]])), info = "All levels in levels_amount have to be present in the corresponding column of the data.")

         }

     }

  }
  # main: ----

  # loop function over all columns that are inserted in form of a vector and corresponding percentages:
  for (i in seq_along(cols)) {

    col <- cols[i]
    perc <- amount[i]


    # Check if the specific column is a factor and has levels_amount defined:
    if (is.factor(data[[col]]) || is.character(data[[col]]) && !is.null(levels_amount) && col %in% names(levels_amount)) {

      # if all these conditions apply for the column, code is executed:
      # get list of different replacement percentages of levels in column:
      lev_amount <- levels_amount[[col]]

      # loop over levels in current column:
      for (cat in names(lev_amount)) {

        # get replacement percentage for current category:
        replace_perc <- lev_amount[[cat]]

        # get rows in column for current category:
        rows <- which(data[[col]] == cat)

        # Calculate how many values should be replaced in category:
        num_replace <-  ifelse(replace_perc <= 1, round(replace_perc * length(rows), 0), replace_perc)

        # Use sample to replace specified percentage of category with replacement input:
        replace_rows <- sample(rows, size = num_replace[1],  replace = FALSE)
        data[replace_rows, col] <- replacement

      }

    } else {

      # Calculate how many values should be replaced:
      num_values <- nrow(data)
      num_replace <-  ifelse(amount <= 1, round(amount * num_values, 0), amount)

      # Use sample to replace specified percentage with replacement input:
      replace_rows <- sample(1:num_values,size = num_replace[1],  replace = FALSE)
      data[replace_rows, col] <- replacement

    }

  }

  # Output: ----

  return(data) # as data frame.

} # replace_values().

```

```{r define-loop-NA-function}

loop_NA <- function(data, criterion, pc, x, fft_df, x_stats_1){


# Prepare for loop:
  # Parameters:
  n_per_NA <- 10
  n_sims <- n_per_NA

# initialize data structure to collect results:
results <- data.frame(matrix(NA, nrow = 1 + n_sims, ncol = 26))

# results:
n_col <- ncol(x_stats_1)
results[1, 1:n_col] <- x_stats_1

  
# Prepare vectors as input for replace_values function:  
   # get all names of variables but exclude criterion: 
   col_names <- names(data)
   col_names <- col_names[col_names != criterion ]
  
   # build vector with NA percentage: 
   num_cols <- length(col_names)
   pc_per_row <- pc

   # create vector with that pc for number of rows:
   pc_vec <- rep(pc_per_row, times = num_cols)

   # set seed for reproducability:
   set.seed(13)
  
# Loop 1: ---- 
for (i in 1:n_sims){

# Add NAs to data:
data_NA <- replace_values(data = data, 
                          cols = col_names, 
                          amount = pc_vec, 
                          replacement = NA, 
                          levels_amount = NULL)

  
# Apply tree definition to (OLD/NBW) data:
y <- FFTrees(object = x,
             tree.definitions = fft_df,
             data = data_NA, 
             quiet = TRUE, 
             do.comp = FALSE)

# Collect results:

# a) tree performance: 
y_summary <- summary(y)
y_stats <- y_summary$stats$train

# b) level stats:
y_level_stats <- y$trees$level_stats$train
NA_stats <- y_level_stats[nrow(y_level_stats) , c(25 :30)]

# Combine:
all_data_df <- cbind(y_stats, NA_stats)
# dim(all_data_df)


# Collect results:
results[(1 + i), ] <- all_data_df

} # for loop. 

  
# After loop:

# Add column names to data frame:
names(results) <- names(all_data_df)

       
# Output: ----
return(results) # as data frame.

} # loop_NA().
```

```{r define-loop-pc-function}

# as input a vector with different pcs for which you want data:

loop_pc <- function(data, data_name, criterion, several_pcs, x, fft_df, x_stats_1){

  # Initialize list to store results:
  results_dataframes <-  list()

  # length of vector, to know when to stop:
  n <- length(several_pcs)

  # Loop 2:
  for (j in 1:n) {

    # use function loop_NA and give name to each data frame:
    result_name <- paste0(data_name, "_", several_pcs[j]*100, "pc")
    results_dataframes[[result_name]] <- loop_NA(data, criterion, several_pcs[j], x, fft_df, x_stats_1)

  } # for loop.
  
  # Output: ----
  
  return(results_dataframes)# as list.

} # loop_pc.

```

```{r define-loop-datasets-function}

# as input a vector with different data sets for which you want data:

loop_datasets <- function(several_data, data_names, several_criterion, several_pcs){

  # Preparations:
  # length of vector, to know when to stop:
  n <- length(several_data)


  # Initialize list to store results:
  results_list_dataframes <-  list()
  
  # Initialize list to store results of Baseline-pc:
  baseline_pc <- numeric(n)

  
  # Initialize two nummeric vectors to store results of Baseline-pc:
  bl <- numeric(n)
  pred_benchmark <- numeric(n)
  
  # Loop 3:
  for (k in 1:n) {

    # build tree with original data for each dataset:
    # get name of data set:
    name <- data_names[k]

    #Build tree for normal data set:
    x <- FFTrees(formula = as.formula(paste(several_criterion[k],"~.")),
                 data = several_data[[k]],
                 main = name,
                 goal = "bacc",
                 goal.chase = "bacc",
                 goal.threshold = "bacc")

    # Performance:
    x_summary <- summary(x)
    x_stats_1 <- x_summary$stats$train[1, ]

    # get tree definitions:
    x_fft_df <- get_fft_df(x)
    fft_df <- x_fft_df[1, ]  # best training tree



    # use function loop_pc:
    results_list_dataframes[[data_names[k]]] <- loop_pc(several_data[[k]], data_names[k], several_criterion[k], several_pcs, x, fft_df, x_stats_1)

    
    
    # describe data for further table:
    dd <- describe_data(several_data[[k]], 
                    data_name = name, 
                    criterion_name = several_criterion[k], 
                    baseline_value = TRUE)

    # Baseline:
    bl[k] <- dd$Baseline_pct

    # Minimum prediction performance (i.e., majority of criterion):
    pred_benchmark[k] <- max(bl[k], 100 - bl[k])/100
    
    # store baseline_pc:
    baseline_pc[k] <- pred_benchmark[k]

    
  } # for loop.
  
  # Output: ----
  
  return(list(results = results_list_dataframes, baseline = baseline_pc)) # as list.

} # loop_datasets.
```

# Handle NA with FFTrees: ----
```{r run-simulation}
# Use function for example 25%: ----

dfs <- loop_datasets(several_data = list(heartdisease),
                      data_names = c("heartdisease"), 
                      several_criterion = c("diagnosis"),
                      several_pcs = c(pc))


# assign names to output dfs: ----
# list of names
names_list <- c("heartdisease")

# list of percentages
pc_100 <- pc * 100
percent_list <- c(pc_100)

# loop over names
for (name in names_list) {
  
  # loop over percentages
  for (percent in percent_list) {
    
    # create the name of the dataframe in dfs$results
    df_name <- paste0(name, "_", percent, "pc")
    
    # create the name of the variable
    var_name <- paste0(name, "_NA_", percent)
    
    # assign the dataframe to a new variable
    assign(var_name, dfs$results[[name]][[df_name]])
  }
}
```

```{r key-results}

# Collect key results (in df): ----
key_results <- data.frame(matrix(NA, nrow = 2, ncol = 5))
names(key_results) <- c("pc_NA", "mn_hi", "mn_fa", "mn_mi", "mn_cr")

# Construct the variable name
input_var <- paste0("heartdisease_NA_", pc_100)

# Row 1: mean values
key_results[1, "pc_NA"] <- pc_100
key_results[1, "mn_hi"] <- mean(get(input_var)$hi[-1])
key_results[1, "mn_fa"] <- mean(get(input_var)$fa[-1])
key_results[1, "mn_mi"] <- mean(get(input_var)$mi[-1])
key_results[1, "mn_cr"] <- mean(get(input_var)$cr[-1])

# Row 2: in pc
key_results[2, "pc_NA"] <- pc_100
key_results[2, "mn_hi"] <- mean(get(input_var)$hi[-1]) / n
key_results[2, "mn_fa"] <- mean(get(input_var)$fa[-1]) / n
key_results[2, "mn_mi"] <- mean(get(input_var)$mi[-1]) / n
key_results[2, "mn_cr"] <- mean(get(input_var)$cr[-1]) / n

key_results
```


```{r calculate_costs}

# probabilities taken from the table above:
 handle_NA_costs <- key_results$mn_hi[2] * cost_hi +
                    key_results$mn_mi[2] * cost_mi +
                    key_results$mn_fa[2] * cost_fa +
                    key_results$mn_cr[2] * cost_cr 
```



# Compare different proceedings: ----
```{r Compare_costs_across_proceedings}

# Compare performances with costs: ----
# Define the column names and values
col_names <- c("original_costs", "IDK_1_costs", "IDK_all_costs", "handle_NA_costs")
values <- as.numeric(c(original_costs, IDK_1_costs, IDK_all_costs, handle_NA_costs))

# Create the data frame
df <- data.frame(t(values))
colnames(df) <- col_names

# Print the data frame
print(df)
```

```{r display_costs_in_barplot}

# Create  bar plot: ----
barplot(height = values, names = col_names, ylim = c(0, 1), xlab = "procedure", ylab = "Performance", main = "Costs of different procedures to handle missings.")
```

